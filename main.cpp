#include "Card.h"
#include <vector>
#include <iostream>

using namespace std;
//============================================================================================================
/*1. –еализовать шаблон класса Pair1, который позвол€ет пользователю передавать данные одного типа парами.
—ледующий код: должен производить результат:
Pair: 6 9
Pair: 3.4 7.8  */
//============================================================================================================
template < class T >
class Pair1
{
T t_a;
T t_b;
public:
    Pair1 (const T a, const T b) { t_a = a; t_b = b;}
    const T& first() const { return t_a; }
    const T& second() const { return t_b;  }
~ Pair1 (){}
};


//============================================================================================================
/*2. –еализовать класс Pair, который позвол€ет использовать разные типы данных в передаваемых парах.
—ледующий код:
Е должен производить следующий результат:
Pair: 6 7.8
Pair: 3.4 5
ѕодсказка: чтобы определить шаблон с использованием двух разных типов,
 просто разделите параметры типа шаблона зап€той.*/
//============================================================================================================

template < class T, class T1 >
class Pair
{
public:
T t_a;
T1 t_b;

    Pair (const T a, const T1 b) { t_a = a; t_b = b;}
    const T& first() const { return t_a; }
    const T1& second() const { return t_b;  }
~ Pair (){}
};

//============================================================================================================
/*3. Ќаписать шаблон класса StringValuePair, в котором первое значение всегда типа string,
а второе Ч любого типа. Ётот шаблон класса должен наследовать частично специализированный класс Pair,
в котором первый параметр Ч string, а второй Ч любого типа данных.
—ледующий код:
Е должен производить следующий результат:
Pair: Amazing 7
ѕодсказка: при вызове конструктора класса **Pair* из конструктора класса StringValuePair
не забудьте указать, что параметры относ€тс€ к классу Pair. **/
//============================================================================================================

template < class T, class T1 >
class StringValuePair: public Pair <string, T1>
{
    public:
    StringValuePair (string  a, const T1 b) : Pair <string, T1> (a, b) {};

~ StringValuePair (){}
};



//============================================================================================================
/*4. —огласно иерархии классов, котора€ представлена в методичке к уроку 3,
от класса Hand наследует класс GenericPlayer, который обобщенно представл€ет игрока,
ведь у нас будет два типа игроков - человек и компьютер.
—оздать класс GenericPlayer, в который добавить поле name - им€ игрока.
“акже добавить 3 метода:
Х IsHitting() - чисто виртуальна€ функци€, возвращает информацию, нужна ли игроку еще одна карта.
Х IsBoosted() - возвращает bool значение, есть ли у игрока перебор
Х Bust() - выводит на экран им€ игрока и объ€вл€ет, что у него перебор.*/
//============================================================================================================
class Hand
{
public:
vector <Card*>  m_Cards;

    Hand (){}
    Hand (vector <Card*>  m_Cards) {}

    void Add (Card* pCard)
    {
        m_Cards.push_back(pCard);
    }

    void Clear ()
    {
        m_Cards.clear();
    }
//============================================================================================================
    int GetValue ()
    {
        int vsum=0;
        for (size_t i=0; i<m_Cards.size(); i++)
        {
            if (vsum < 21)
            {
                if ((static_cast <int> (m_Cards[i] -> c_value)) != 1)
                {
                    vsum += (static_cast <int> (m_Cards[i] -> c_value));
                }
                else if ((vsum + 10)>21)
                    {
                        vsum += (static_cast <int> (m_Cards[i] -> c_value));
                    }
                    else vsum += 11;
            } else vsum += (static_cast <int> (m_Cards[i] -> c_value));
        }
       // cout <<  vsum << " - sum " << endl;

        return  vsum;
    }
//============================================================================================================
    void printHand()
    {
        for (size_t i=0; i<m_Cards.size(); i++)
        {
            cout << " ' "<< static_cast <char> (m_Cards[i] ->c_suit) << " ' ";
            cout << static_cast <int> (m_Cards[i] ->c_value) << " ' ";
            cout <<  m_Cards[i] ->c_upPosition << " ' " << endl;
        }
    }
};
//============================================================================================================
class GenericPlayer : public Hand
{
public:
string p_name;
    GenericPlayer (){}

    GenericPlayer ( string name ) { p_name = name; }

    virtual bool IsHitting() = 0; /*{};*/ //- чисто виртуальна€ функци€, возвращает информацию, нужна ли игроку еще одна карта.
    bool IsBoosted()
    {
        if (Hand::GetValue()>21)
        return true;
    } //- возвращает bool значение, есть ли у игрока перебор
    void Bust()
    {
        if (IsBoosted())
        cout << "The player " << p_name << " has busted! " << endl;
    } //выводит на экран им€ игрока и объ€вл€ет, что у него перебор.
    ~GenericPlayer (){}
};


//============================================================================================================
int main()
{
//============================================================================================================
cout << "1st task: Template Pair1 " << endl;
cout << endl;

Pair1<int> p1(6, 9);
cout << "Pair: " << p1.first() << ' ' << p1.second() << '\n';

Pair1<double> p2(3.4, 7.8);
cout << "Pair: " << p2.first() << ' ' << p2.second() << '\n';

cout << endl;
//============================================================================================================
//============================================================================================================
cout << "2st task: class Pair " << endl;
cout << endl;

Pair<int, double> p3(6, 7.8);
cout << "Pair: " << p3.first() << ' ' << p3.second() << '\n';

const Pair<double, int> p4(3.4, 5);
cout << "Pair: " << p4.first() << ' ' << p4.second() << '\n';

cout << endl;
//============================================================================================================
//============================================================================================================
cout << "3st task: Template StringValuePair " << endl;
cout << endl;

StringValuePair<string, int> svp("Amazing", 7);
std::cout << "Pair: " << svp.first() << ' ' << svp.second() << '\n';

cout << endl;
//============================================================================================================
//============================================================================================================
cout << "4st task:  GenericPlayer test " << endl;
cout << endl;
    /*Card ace (Card::e_suit::Diamonds,Card::e_value::Ace,0);
    Card king (Card::e_suit::Diamonds,Card::e_value::King,0);
    Card six (Card::e_suit::Diamonds,Card::e_value::six,0);
    GenericPlayer p ("Piter");
    p.Add(&king);
    p.Add(&six);
    p.Add(&ace);
    p.Add(&king);
    p.Bust();
    p.Clear();
cout << endl;*/
//============================================================================================================
return 0;
}
